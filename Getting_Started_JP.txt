Getting Started | PixiJS
https://pixijs.com/guides/basics/getting-started

■■ はじめる
このセクションでは、最も単純な PixiJS アプリケーションを構築します。 その際、コードを構築して提供する方法の基本について説明します。

■ 上級ユーザー
始める前に簡単な注意: このガイドは、JavaScript ベースのアプリケーションの開発経験が最小限の PixiJS 開発者を対象としています。
コーディングのベテランの場合、ここでの詳細レベルは役に立たないと思われるかもしれません。 
その場合は、このガイドをざっと読んでから、PixiJS と webpack や npm などのパッカーの操作方法（注：リンク先#TODO）に進んでください。

■ JavaScript に関する注意事項
最後に注意点を 1 つ。 JavaScript の世界は現在、旧来の JavaScript (ES5) から新しい ES6 フレーバーへの移行中です。

// ES5
var x = 5;
setTimeout(function() { アラート(x); }, 1000);

// ES6
定数 x = 5;
setTimeout(() => アラート(x), 1000);

ES6 は、より明確な構文、より優れた変数スコープ、ネイティブ クラスのサポートなどの点で、多くの大きな利点をもたらします。現在では、すべての主要なブラウザが ES6 をサポートしています。 
これを考慮して、これらのガイドの例では ES6 を使用します。 これは、ES5 プログラムで PixiJS を使用できないという意味ではありません。 
頭の中で「let/const」を「var」に置き換え、短い関数受け渡し構文を拡張するだけで、すべてが正常に実行されます。

■ PixiJS アプリケーションのコンポーネント
わかりました！ メモはこれくらいにして、始めましょう。 PixiJS アプリケーションを作成するために必要な手順はわずかです。

・HTMLファイルを作成する
・Webサーバーでファイルを提供する
・PixiJS ライブラリをロードする
・アプリケーションを作成する
・生成されたビューを DOM に追加します
・ステージに画像を追加する
・更新ループを作成する

一緒にそれらを見ていきましょう。

■ HTML ファイル
PixiJS は、Web ページ内で実行される JavaScript ライブラリです。 したがって、最初に必要となるのは、ファイル内の HTML です。 
実際の PixiJS アプリケーションでは、複雑な既存のページ内に表示を埋め込んだり、表示領域をページ全体に埋めたい場合があります。 このデモでは、まず空のページを作成します。

<!doctype html>
<html>
   <head>
   </head>
   <body>
     <h1>こんにちは、PixiJS</h1>
   </body>
</html>

pixi-test という名前の新しいフォルダーを作成し、この HTML をコピーして、index.html という名前の pixi-test フォルダー内の新しいファイルに貼り付けます。

■ ファイルの提供
PixiJS を使用してローカルで開発するには、Web サーバーを実行する必要があります。 
Web ブラウザでは、ローカルに読み込まれた Web ページにローカル ファイル (画像や音声ファイルなど) を読み込むことができません。 
新しい HTML ファイルをダブルクリックしただけでは、PixiJS ステージにスプライトを追加しようとするとエラーが発生します。

Web サーバーの実行は複雑で難しいように思えますが、この目的に適した単純な Web サーバーが多数あることが判明しています。 
このガイドでは、Mongoose を使用して作業しますが、XAMPP または http-server Node.js パッケージを同様に簡単に使用してファイルを提供することもできます。

Mongoose でページの提供を開始するには、Mongoose のダウンロード ページに移動し、オペレーティング システム用の無料サーバーをダウンロードします。
Mongoose はデフォルトで実行されているフォルダー内のファイルを提供するため、ダウンロードした実行可能ファイルを前の手順で作成したフォルダー (pixi-test) にコピーします。
 実行可能ファイルをダブルクリックし、そのファイルの実行を信頼することをオペレーティング システムに伝えると、Web サーバーが実行され、新しいフォルダーが提供されます。

選択したブラウザを開いて、ロケーション バーに http://127.0.0.1:8080 と入力して、すべてが動作していることをテストします。
 (Mongoose はデフォルトでポート 8080 でファイルを提供します。)
 「Hello PixiJS」だけが表示されるはずです。 このステップでエラーが発生した場合は、ファイルにindex.htmlという名前を付けていないか、Webサーバーの構成が間違っていることを意味します。

■ PixiJSの読み込み
OK、Web ページがあり、それを提供しています。 でも空いてるよ。 次のステップは、実際に PixiJS ライブラリをロードすることです。
 実際のアプリケーションを構築している場合は、Pixi Github リポジトリから PixiJS のターゲット バージョンをダウンロードして、バージョンが変更されないようにする必要があります。
  ただし、このサンプル アプリケーションでは、PixiJS の CDN バージョンのみを使用します。 次の行を、index.html ファイルの <head> セクションに追加します。

<script src="https://pixijs.download/release/pixi.js"></script>

これには、ページの読み込み時にすぐに使用できる、PixiJS の最新バージョンの縮小されていないバージョンが含まれます。z
開発中のため、縮小されていないバージョンを使用します。 運用環境では、代わりに pixi.min.js を使用することをお勧めします。
これはダウンロードを高速化するために圧縮されており、プロジェクトのビルド時に役立つアサーションと非推奨の警告が除外されていますが、ダウンロードと実行には時間がかかります。

■ アプリケーションの作成
ライブラリをロードしても、それを使用しなければ意味がありません。そのため、次のステップは PixiJS を起動することです。
まず、行 <h1>Hello PixiJS</h1> を次のようなスクリプト タグに置き換えます。

<script>
   let app = new PIXI.Application({ width: 640, height: 360 });
</script>

ここで行っていることは、JavaScript コード ブロックを追加し、そのブロック内で新しい PIXI.Application インスタンスを作成することです。
Application は、PixiJS の操作を簡素化するヘルパー クラスです。
レンダラーを作成し、ステージを作成し、更新のためのティッカーを開始します。
運用環境では、カスタマイズと制御を追加するためにこれらの手順を自分で実行することがほぼ確実になります。
これについては後のガイドで説明します。 今のところ、Application クラスは、詳細を気にせずに PixiJS を使い始めるのに最適な方法です。

■ DOM へのビューの追加
PIXI.Application クラスはレンダラーを作成するときに、レンダリング先の Canvas 要素を構築します。 
PixiJS で何を描画するかを確認するには、この Canvas 要素を Web ページの DOM に追加する必要があります。 ページのスクリプト ブロックに次の行を追加します。

   document.body.appendChild(app.view);

これにより、アプリケーションによって作成されたビュー (Canvas 要素) が取得され、ページの本文に追加されます。

■ スプライトの作成
これまでのところ、私たちが行っているのは準備作業だけです。 実際には、PixiJS に何も描画するように指示していません。
表示する画像を追加してこの問題を修正しましょう。

PixiJS で画像を描画する方法は数多くありますが、最も簡単なのはスプライトを使用する方法です。 
シーン グラフがどのように機能するかについては後のガイドで詳しく説明しますが、現時点で知っておく必要があるのは、PixiJS が DisplayObject の階層をレンダリングするということだけです。
スプライトは、読み込まれた画像リソースをラップして描画、拡大縮小、回転などを行うことができる DisplayObject の一種です。

PixiJS が画像をレンダリングできるようにするには、画像をロードする必要があります。
他の Web ページと同様に、画像の読み込みは非同期で行われます。
リソースの読み込みについては、後のガイドで詳しく説明します。 現時点では、PIXI.Sprite クラスのヘルパー メソッドを使用して、画像の読み込みを処理できます。

   // 魔法のように PNG を非同期でロードします
   let sprite = PIXI.Sprite.from('sample.png');

ここからサンプル PNG をダウンロードし、index.html の隣の pixi-test ディレクトリに保存します。

■ ステージにスプライトを追加する
最後に、新しいスプライトをステージに追加する必要があります。 ステージは、シーン グラフのルートである単なるコンテナです。
ステージ コンテナのすべての子はフレームごとにレンダリングされます。 スプライトをステージに追加することで、PixiJS のレンダラーにそれを描画したいことを伝えます。

   app.stage.addChild(sprite);

■ 更新ループの作成
PixiJS は静的コンテンツに使用できますが、ほとんどのプロジェクトではアニメーションを追加する必要があります。
私たちのサンプル アプリは実際に高速で動作し、同じスプライトを同じ場所に 1 秒間に複数回レンダリングします。
画像を動かすために必要なのは、フレームごとに属性を 1 回更新することだけです。
これを行うには、アプリケーションのティッカーにフックします。 
ティッカーは、フレームごとに 1 つ以上のコールバックを実行する PixiJS オブジェクトです。 
それは驚くほど簡単です。 スクリプト ブロックの最後に次のコードを追加します。

   // デモが実行されている秒数をカウントするための変数を追加します
   let elapsed = 0.0 とします。
   // アプリケーションのティッカーに、フレームごとに新しいコールバックを実行するように指示し、
   // 最後のティックからの経過時間
   app.ticker.add((delta) => {
     // 合計経過時間に時間を加算します
     elapsed += delta;
     // 経過時間のコサインに基づいてスプライトの X 位置を更新します。 分けます
     // アニメーションを少し遅くするために 50 ずつ...
     sprite.x = 100.0 + Math.cos(経過/50.0) * 100.0;
   });


必要なのは、app.ticker.add(...) を呼び出してコールバック関数に渡し、その関数でシーンを更新することだけです。
これはフレームごとに呼び出され、プロジェクトのアニメーションを駆動するために移動、回転などを何でも行うことができます。

■ すべてを一緒に入れて
それでおしまい！ 最も単純なPixiJSプロジェクト!

すべてが 1 か所にまとめられています。ファイルをチェックし、エラーが発生する場合はファイルが一致していることを確認してください。

<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://pixijs.download/release/pixi.js"></script>
</head>

<body>

    <!-- <h1>こんにちは、PixiJS</h1> -->

    <script>

        // PIXI.Applicationインスタンスを作成
        let app = new PIXI.Application({ width: 640, height: 360 });

        // PIXI.Applicationが描画するCanvasをhtml内に追加
        document.body.appendChild(app.view);

        // 魔法のようにPNGを非同期でロードします
        let sprite = PIXI.Sprite.from('sample.png');

        // ステージに読み込んだpng（sprite化）を表示する
        app.stage.addChild(sprite);

        // デモが実行されている秒数をカウントするための変数を追加します
        let elapsed = 0.0;
        // アプリケーションのティッカーに、フレームごとに新しいコールバックを実行するように指示し、
        // 最後のティックからの経過時間
        app.ticker.add((delta) => {
            // 合計経過時間に時間を加算します
            elapsed += delta;
            // 経過時間のコサインに基づいてスプライトの X 位置を更新します。 分けます
            // アニメーションを少し遅くするために 50 ずつ...
            sprite.x = 100.0 + Math.cos(elapsed / 50.0) * 100.0;
        });

    </script>

</body>

</html>

物事が機能するようになったら、次に行うべきことは、残りの基本ガイドを読んで、これらすべてがどのように機能するかをより深く掘り下げることです。



